# JS

### 1.原型 / 构造函数 / 实例

[原型](https://github.com/KieSun/Dream/issues/2)

- 原型`(prototype)`: 一个简单的对象，用于实现对象的 属性继承。可以简单的理解成对象的爹。在 Firefox 和 Chrome 中，每个JavaScript对象中都包含一个`__proto__` (非标准)的属性指向它爹(该对象的原型)，可`obj.__proto__`进行访问。
- 构造函数: 可以通过`new`来 新建一个对象 的函数。
- 实例: 通过构造函数和new创建出来的对象，便是实例。 实例通`过__proto__`指向原型，通过`constructor`指向构造函数。
- [实例](https://user-gold-cdn.xitu.io/2019/2/14/168e9d9b940c4c6f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

### 2.原型链

**原型链是由原型对象组成**，每个对象都有` __proto__` 属性，指向了创建该对象的构造函数的原型，`__proto__` 将对象连接起来组成了原型链。是一个用来实现继承和共享属性的有限的对象链。

### 3.执行上下文

- 类型
   - 全局执行上下文
   - 函数执行上下文
   - `eval`执行上下文

- 包含三个部分
   - 变量对象
   - 作用域链
   - `this`指向
  
- 代码执行过程
   - 创建全局上下文
   - 全局上下文自上而下执行代码
   - 遇到函数时，被`push`到执行栈中顶层
   - 开始执行函数中的代码
   - 函数执行完成后`pop`移除栈，全局上下文继续执行

### 4.闭包

- 闭包的定义很简单：函数 A 返回了一个函数 B，并且函数 B 中使用了函数 A 的变量，函数 B 就被称为闭包。
- 父函数被销毁 的情况下，返回出的子函数的`[[scope]]`中仍然保留着父级的单变量对象和作用域链，因此可以继续访问到父级的变量对象，这样的函数称为闭包。

- 闭包会产生一个很经典的问题:
   - 多个子函数的`[[scope]]`都是同时指向父级，是完全共享的。因此当父级的变量对象被修改时，所有子函数都受到影响。

- 解决：
   - 变量可以通过**函数参数的形式**传入，避免使用默认的`[[scope]]`向上查找
   - 使用`setTimeout`包裹，通过第三个参数传入
   - 使用**块级作用域**，让变量成为自己上下文的属性，避免共享

###  5.script的引入方式

- `<script defer>`: 立即请求文件，但不阻塞渲染引擎，而是文件加载完毕后阻塞渲染引擎并立即执行文件内容。

- `<script async>`: 立即请求文件，但不阻塞渲染引擎，等到解析完 HTML 之后再执行文件内容。

- **HTML5 标准 type 属性**：对应值为“module”。让浏览器按照 ECMA Script 6 标准将文件当作模块进行解析，默认阻塞效果同 defer，也可以配合 async 在请求完成后立即执行。

###  6.赋值、浅拷贝和深拷贝的区别

- 赋值是将某一数值或对象赋给某个变量的过程

   - 基本数据类型：赋值，赋值之后两个变量互不影响
   - 引用数据类型：赋址，两个变量具有相同的引用，指向同一个对象，相互之间有影响

- 浅拷贝

   - 创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 ，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。

   - `Object.assign()`: 用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。

   - 展开语法

   - `Array.prototype.slice()`

- 深拷贝

   - 深拷贝: 完全拷贝一个新对象，修改时原对象不再受到任何影响

   - `JSON.parse(JSON.stringify(object))`: 
    
      - 会忽略`undefined`
      - 会忽略`symbol`
      - 不能序列化函数
      - 不能解决循环引用的对象
      - 不能正确处理new Date()
      - 不能处理正则
      - `undefined`、`symbol` 和函数这三种情况，会直接忽略。
   - 递归进行逐一赋值

- `new`

   - 创建一个用户定义的对象类型的实例或具有构造函数的内置对象的实例
   - `bind`返回的是一个新的函数，你必须调用它才会被执行
   - `call, apply` 会执行函数

- `instanceof`

   - `instanceof`可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的`prototype`






